<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width" />
    </head>

    <body>
        <div id="root" class="root"></div>
        <script>
            function Node(key) {
                this.children = {};
                this.len = 0; //最长子串的长度（该节点的子串数量=this.len - this.fail.len）
                this.isEnd = false;
                this.num = 0; // 该状态子串的数量
                this.key = key;
                this.count = 0; //被后缀链接的个数，方便求节点字符串的个数
                this.fail = null;
            }

            class SuffixAutomaton {
                constructor() {
                    var node = (this.root = this.last = new Node(""));
                    this.nodes = [node];
                }
                extend(word) {
                    for (var i = 0; i < word.length; i++) {
                        this.insert(word[i]);
                    }
                }
                insert(c, n) {
                    var p = this.last;
                    var node = new Node(c);
                    node.len = p.len + 1;
                    node.num = 1;
                    this.last = node;
                    this.nodes.push(node);
                    while (p && !p.children[c]) {
                        //如果p 没有一条 c 的出边
                        p.children[c] = node; //为a为一个c
                        p = p.fail;
                    }
                    if (!p) {
                        node.fail = this.root;
                        this.root.count++;
                    } else {
                        var q = p.children[c];
                        if (p.len + 1 == q.len) {
                            node.fail = q;
                            q.count++;
                            q.isEnd = true; //主轴上冲突
                        } else {
                            var clone = new Node(c); //克隆节点
                            this.nodes.push(clone);
                            clone.children = q.children;
                            clone.fail = q.fail;
                            clone.len = p.len + 1;
                            clone.isEnd = true;
                            while (p && p.children[c] == q) {
                                p.children[c] = clone; //将树中所有q相关的链接替换成clone
                                p = p.fail;
                            }
                            clone.count += 2;
                            q.fail = node.fail = clone;
                        }
                    }
                }
            }
            //alsdfkjfjkdsal
            //fdjskalajfkdsla
            //aaaajfaaaa
            function getLCS(strs) {
                var s = strs.shift();
                var sam = new SuffixAutomaton();

                sam.extend(s);

                var count = [];
                for (var i = 0; i <= s.length; i++) {
                    count[i] = 0;
                }
                //根据节点的lenn属性进行计数排序
                var nodes = sam.nodes;
                for (var i = 0; i < nodes.length; i++) {
                    count[nodes[i].len]++;
                }
                for (var i = 1; i <= s.length; i++) {
                    count[i] += count[i - 1];
                }
                var sa = [];
                for (var i = nodes.length - 1; i >= 0; i--) {
                    sa[--count[nodes[i].len]] = nodes[i];
                }

                console.log(count, sa);
            }
            console.log(getLCS(["uabcdefo", "dabcdui"])); //abcd
            // console.log(getLCS("alsdfkjffkdsal", "fdjskalajfkdsla")); //fkds
        </script>
    </body>
</html>
