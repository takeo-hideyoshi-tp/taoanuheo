<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <title>Document</title>
    </head>

    <body>
        <script>
            class SuffixNode {
                constructor(value) {
                    this.value = value;
                    this.splitLength = 0;
                    this.isActive = false;
                    this.children = [];
                    this.unfork = false;
                    this.hidden = false;
                }
            }
            class SuffixLink {
                constructor(node) {
                    this.node = node;
                    this.unfork = true;
                    this.isActive = false;
                }
                get children() {
                    return this.node.children;
                }
                get splitLength() {
                    return this.node.splitLength;
                }
                get value() {
                    return this.node.value;
                }
            }
            class SuffixTree {
                constructor() {
                    this.root = new SuffixNode("");
                }
                insert(word, sign) {
                    sign = sign || "#";
                    var nodes = this.root.children;
                    word += sign;
                    for (var i = 0; i < word.length; i++) {
                        var multipleActive = [];
                        this.addNodeByChar(
                            nodes,
                            word[i],
                            false,
                            multipleActive
                        );
                    }
                }

                addNodeByChar(nodes, ch, isChild, multipleActive) {
                    var add = true;
                    if (isChild) {
                        add = false;
                    }
                    for (var i = 0; i < nodes.length; i++) {
                        var node = nodes[i];
                        if (node.unfork) {
                            //unfork用于忽略遍历
                            continue;
                        }
                        if (!node.hidden) {
                            //hidden用于忽略修改value
                            node.value += ch;
                        }
                        var isMatch = node.value[node.splitLength] === ch;

                        if (!isMatch) {
                            if (node.isActive) {
                                //处于激活狀态
                                node.isActive = false;
                                node.hidden = true; //进行分叉
                                var value = node.value;
                                node.value = value.slice(0, node.splitLength); //变成父节点
                                node.children.push(
                                    new SuffixNode(
                                        value.slice(node.splitLength, -1)
                                    ),
                                    new SuffixNode("")
                                );
                                node.splitLength = 0;
                            }
                        } else {
                            //命中了，就不用在根节点中添加新节点
                            add = false;
                            node.splitLength++;
                            if (!node.hidden) {
                                //没有分叉过
                                node.isActive = true;
                                if (multipleActive.length) {
                                    //如果存在多个激活节点，那么将它们链接起来，减少更新的数量
                                    var prev = multipleActive[0];
                                    if (prev.value.length > node.value.length) {
                                        prev.value = prev.value.slice(
                                            0,
                                            node.value.length * -1
                                        );
                                        multipleActive[0] = node;
                                        //为了防止重复添加子节点，带有suffixLink的父节点也带上link
                                        prev.unfork = true;
                                        //重置它的属性
                                        prev.isActive = false;
                                        prev.splitLength = 0;
                                        prev.children = [new SuffixLink(node)];
                                    } else {
                                        nodes[i] = new SuffixLink(prev);
                                    }
                                } else {
                                    multipleActive.push(node);
                                }
                            }
                        }
                        //如果有孩子，可以继续传递ch
                        if (node.children.length ) {
                            this.addNodeByChar(node.children, ch, true, multipleActive);
                        }
                    }

                    if (add && ch !== "#") {
                        nodes.push(new SuffixNode(ch));
                    }
                }
            }

            var tree = new SuffixTree();
            //tree.insert("banana");
            tree.insert("abcabxabcd"); //con
            console.log(tree);
        </script>
        <div id="root"></div>
    </body>
</html>
