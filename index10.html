<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">


</head>

<body>


    <div id='root' class="root">

    </div>
    <script>
        function swap(arr, i, j) {
            var tmp = arr[i];
            arr[i] = arr[j]
            arr[j] = tmp;
        }

        function shik(array, i, n) {
            var temp = array[i]; //保存父元素
            for (var k = i * 2 + 1; k < n; k = k * 2 + 1) { //从i结点的左孩子开始
                if (k + 1 < n && array[k] < array[k + 1]) { //挑出最大的孩子
                    k++;
                }
                if (k < n && temp < array[k]) { //如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
                    array[i] = array[k];
                    i = k;
                } else {
                    break;
                }
            }
            array[i] = temp; //将temp值放到最终的位置
        }

        function swap(arr, i, j) {
            var tmp = arr[i];
            arr[i] = arr[j]
            arr[j] = tmp;
        }

        function Adjustdown(top, root, K) {
            var parent = root;
            var child = 2 * parent + 1;
            while (parent < K) {
                //右孩子存在且小于K且右孩子小于左孩子
                if (child + 1 < K && top[child + 1] < top[child])
                    child++; //将child指向更小的结点
                //当前较小孩子小于父节点时交换，并下滤
                if (child < K && top[child] < top[parent]) {
                    swap(top, child, parent);
                    parent = child;
                    child = (child << 1) + 1;
                } else
                    break;
            }
        }

       

        function findBargests(array, k) {
            var top = [],
                n = array.length
            for (var i = 0; i < k; i++) {
                top[i] = array[i];
			}
			console.log(top.concat())
            //下调
            for (var j = k >> 1; j >= 0; --j) {
                Adjustdown(top, j, k);
            }
            for (var j = k; j < n; j++) {
                if (top[0] < array[j]) { //堆顶小于新比较的元素交换
                    swap(top, 0, j);
                    Adjustdown(top, 0, k); //调整最大堆的结构
                }
			}
			console.log(top)
            //遍历完成，top数据内存储的就是最大的前K个数
            for (var idx = 0; idx < k; ++idx) {
               console.log(  top[idx]  )
            }
        }
      
        var el = findBargests([3, 11, 1, 5, 6, 9, 7, 8], 4)
       
    </script>


</html>