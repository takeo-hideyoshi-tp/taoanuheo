<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">


</head>

<body>


    <div id='root' class="root">

    </div>
    <script>
        class Node {
            constructor(data) {
                this.size = 1
                this.data = data;
                this.left = null;
                this.right = null;
                this.parent = null;
            }
            update() {
                var leftSize = this.left ? this.left.size : 0
                var rightSize = this.right ? this.right.size : 0

                this.size = leftSize + rightSize + 1;
                console.log(this.data, this.size, "====")
            }

        };

        function getData(node) {
            return node ? node.data : 0
        }
        class SBT {
            constructor() {
                this.root = null;
                this._size = 0;
            }
            leftRotate(node) {
                if (!node.right) {
                    return;
                }
                var child = node.right;
                node.right = child.left;
                if (child.left) {
                    //过继孩子
                    child.left.parent = node; //父属性修正1
                }
                child.parent = node.parent; //父属性修正2
                //下面都一样
                if (!node.parent) {
                    this.root = child;
                } else if (node == node.parent.left) {
                    node.parent.left = child;
                } else {
                    node.parent.right = child;
                }
                node.parent = child; //父属性修正3
                child.left = node; //旋转
              
                child.update();
                node.update();
            }
            getSize(node) {
                return node ? node.size : 0
            }
            rightRotate(node) {
                if (!node.left) {
                    return;
                }
                var child = node.left;
                node.left = child.right;
                //  console.log("rightRotate 1")
                if (child.right) {
                    //过继孩子
                    child.right.parent = node; //父属性修正1
                }
                child.parent = node.parent; //父属性修正2
                //下面都一样
                if (!node.parent) {
                    this.root = child;
                } else if (node == node.parent.left) {
                    node.parent.left = child;
                } else {
                    node.parent.right = child;
                }
                node.parent = child; //父属性修正3
                child.right = node; //旋转
               
                child.update();
                node.update();
            }
            maintain(node, rightDeeper) {
                var left = node.left,
                    right = node.right;

                // if (left && right) {
                if (!rightDeeper) {
                  
                    var rightSize = right && right.size || 0
                    console.log("===",left, rightSize)
                    if (left && left.left && left.left.size > rightSize) {
                        //左边高
                        this.rightRotate(node);
                    } else if (left && left.right && left.right.size > rightSize) {
                        //左边高
                        this.rightRotate(node);
                        this.leftRotate(left);

                    } else {
                        return;
                    }

                } else {

                    var leftSize = left && left.size || 0
                    if (right && right.right && right.right.size > leftSize) {
                        this.leftRotate(node);
                    } else if (right && right.left && right.left.size > leftSize) {
                        this.leftRotate(node);
                        this.rightRotate(right);

                    } else {
                        return;
                    }
                }
                //为什么Maintain(left,true)和Maintain(right,false)被省略了呢？
                //您可以在陈启峰论文第六部分的分析中找到答案。
                left && this.maintain(left, false);
                right && this.maintain(right, true);
                this.maintain(node, false);
                this.maintain(node, true);
                //  }
            }

            size() {
                return this.root ? this.root.size : 0
            }
            find(data) {
                var node = this.root;
                while (node) {
                    var diff = data - node.data
                    if (diff == 0) {
                        break
                    } else if (diff < 0) {
                        node = node.left;
                    } else {
                        node = node.right;
                    }
                }
                if (node) {
                    return node
                }
                return null
            }
            insert(data) {
                if (!this.root) {
                    this.root = new Node(data);
                    this._size++;
                    return true
                }

                var node = this.root,
                    parent = null
                while (node) {
                    parent = node; //保存要插入的父节点
                    parent.size++
                    var diff = data - node.data
                    if (diff == 0) {
                        return false
                    } else if (diff < 0) {
                        node = node.left;
                    } else {
                        node = node.right;
                    }
                }
                var node = new Node(data);
                node.parent = parent;

                this._size++;
                if (diff < 0) {
                    parent.left = node
                } else {
                    parent.right = node
                }
                console.log("diff", diff > 0)
                this.maintain(this.root, diff > 0);
                return true;
            }
            remove(data) {
                if (!this.root) {
                    return false
                }
                var node = this.find(data); //如果找到，内部会进行伸展
                if (node) {
                    if (data == this.root.data) {
                        if (node.left && node.right) {
                            var succ = this.maxNode(node.left); //求后继
                            node.data = succ.data;
                            this.remove(succ)
                        } else {
                            this._size--;
                            var child = node.left || node.right || null;
                            var parent = node.parent;
                            if (parent.left == node) {
                                node.left = child
                            } else {
                                node.right = child
                            }
                            if (child) {
                                child.parent = parent; //parent的size发生变化
                                this.maintain(parent, false);
                                this.maintain(parent, true);
                            }
                        }
                    }
                }
            }

            maxNode(node) {
                var current = node || this.root;
                while (current.right) {
                    current = node.right
                }
                return current;
            }
            toString(printNode) {
                if (printNode === void 0) printNode = function (n) {
                    return n.data;
                };

                var out = [];
                printRow(this.root, '', true, function (v) {
                    return out.push(v);
                }, printNode);
                return out.join('');
            };
        }

        // https://github.com/w8r/splay-tree/blob/master/dist/splay.js
        function printRow(root, prefix, isTail, out, printNode) {
            if (root) {
                out(("" + prefix + (isTail ? '└── ' : '├── ') + (printNode(root)) + "\n"));
                var indent = prefix + (isTail ? '    ' : '│   ');
                if (root.left) {
                    printRow(root.left, indent, false, out, printNode);
                }
                if (root.right) {
                    printRow(root.right, indent, true, out, printNode);
                }
            }
        }
        var tree = new SBT(); //40, 30, 20, 60
        [10, 50, 40, 30,20,60].forEach(function (el, i) {
            tree.insert(el)
        })
        //   tree.remove(60)
        //  console.log(tree.root, "开始删30")
        //  tree.remove(30)
        console.log(tree + "")
        console.log(tree)

        /*
        https://blog.csdn.net/BerryKanry/article/details/75448176
        https://github.com/JWLee89/The-Coding-Delight/blob/master/Java/data-structures/AVL-tree/AvlTree.java
        https://github.com/GodTamIt/java-iterative-avl-tree/blob/master/src/AVL.java

        区间树能够对保存的数据进行适当的预处理，以快速回复查询。

区间树常用于在一维数组的特定区间对查询进行快速回复。区间树的最典型也是最简单的应用就是求区间最小值的问题。

区间树的基本思路是，生成表示给定数组各区间的二叉树。
        */
    </script>


</html>