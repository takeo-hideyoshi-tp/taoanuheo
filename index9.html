<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">


</head>

<body>


    <div id='root' class="root">

    </div>
    <script>
        var Node = function(key, value) {
            this.left = null;
            this.right = null;
            this.height = null;
            this.key = key;
            this.value = value;
        };

        /**
         * Performs a right rotate on this node.
         *
         *       b                           a
         *      / \                         / \
         *     a   e -> b.rotateRight() -> c   b
         *    / \                             / \
         *   c   d                           d   e
         *
         * @return {Node} The root of the sub-tree; the node where this node used to be.
         */
        Node.prototype.rotateRight = function() {
            var other = this.left;
            this.left = other.right;
            other.right = this;
            this.height = Math.max(this.leftHeight(), this.rightHeight()) + 1;
            other.height = Math.max(other.leftHeight(), this.height) + 1;
            return other;
        };

        /**
         * Performs a left rotate on this node.
         *
         *     a                              b
         *    / \                            / \
         *   c   b   -> a.rotateLeft() ->   a   e
         *      / \                        / \
         *     d   e                      c   d
         *
         * @return {Node} The root of the sub-tree; the node where this node used to be.
         */
        Node.prototype.rotateLeft = function() {
            var other = this.right;
            this.right = other.left;
            other.left = this;
            this.height = Math.max(this.leftHeight(), this.rightHeight()) + 1;
            other.height = Math.max(other.rightHeight(), this.height) + 1;
            return other;
        };

        /**
         * Convenience function to get the height of the left child of the node,
         * returning -1 if the node is null.
         *
         * @return {number} The height of the left child, or -1 if it doesn't exist.
         */
        Node.prototype.leftHeight = function() {
            if (!this.left) {
                return -1;
            }
            return this.left.height;
        };

        /**
         * Convenience function to get the height of the right child of the node,
         * returning -1 if the node is null.
         *
         * @return {number} The height of the right child, or -1 if it doesn't exist.
         */
        Node.prototype.rightHeight = function() {
            if (!this.right) {
                return -1;
            }
            return this.right.height;
        };
        var AvlTree = function(customCompare) {
            this._root = null;
            this._size = 0;

            if (customCompare) {
                this._compare = customCompare;
            }
        };

        /**
         * Compares two keys with each other.
         *
         * @private
         * @param {Object} a The first key to compare.
         * @param {Object} b The second key to compare.
         * @return {number} -1, 0 or 1 if a < b, a == b or a > b respectively.
         */
        AvlTree.prototype._compare = function(a, b) {
            if (a > b) {
                return 1;
            }
            if (a < b) {
                return -1;
            }
            return 0;
        };

        /**
         * Inserts a new node with a specific key into the tree.
         *
         * @param {Object} key The key being inserted.
         * @param {Object} value The value being inserted.
         */
        AvlTree.prototype.insert = function(key, value) {
            this._root = this._insert(key, value, this._root);
            this._size++;
        };

        /**
         * Inserts a new node with a specific key into the tree.
         *
         * @private
         * @param {Object} key The key being inserted.
         * @param {Object} value The value being inserted.
         * @param {Node} root The root of the tree to insert in.
         * @return {Node} The new tree root.
         */
        AvlTree.prototype._insert = function(key, value, root) {
            // Perform regular BST insertion
            if (root === null) {
                return new Node(key, value);
            }

            if (this._compare(key, root.key) < 0) {
                root.left = this._insert(key, value, root.left);
            } else if (this._compare(key, root.key) > 0) {
                root.right = this._insert(key, value, root.right);
            } else {
                // It's a duplicate so insertion failed, decrement size to make up for it
                this._size--;
                return root;
            }

            // Update height and rebalance tree
            root.height = Math.max(root.leftHeight(), root.rightHeight()) + 1;
            var balanceState = getBalanceState(root);

            if (balanceState === BalanceState.UNBALANCED_LEFT) {
                if (this._compare(key, root.left.key) < 0) {
                    // Left left case
                    root = root.rotateRight();
                } else {
                    // Left right case
                    root.left = root.left.rotateLeft();
                    return root.rotateRight();
                }
            }

            if (balanceState === BalanceState.UNBALANCED_RIGHT) {
                if (this._compare(key, root.right.key) > 0) {
                    // Right right case
                    root = root.rotateLeft();
                } else {
                    // Right left case
                    root.right = root.right.rotateRight();
                    return root.rotateLeft();
                }
            }

            return root;
        };

        /**
         * Deletes a node with a specific key from the tree.
         *
         * @param {Object} key The key being deleted.
         */
        AvlTree.prototype.delete = function(key) {
            this._root = this._delete(key, this._root);
            this._size--;
        };

        /**
         * Deletes a node with a specific key from the tree.
         *
         * @private
         * @param {Object} key The key being deleted.
         * @param {Node} root The root of the tree to delete from.
         * @return {Node} The new tree root.
         */
        AvlTree.prototype._delete = function(key, root) {
            // Perform regular BST deletion
            if (root === null) {
                this._size++;
                return root;
            }

            if (this._compare(key, root.key) < 0) {
                // The key to be deleted is in the left sub-tree
                root.left = this._delete(key, root.left);
            } else if (this._compare(key, root.key) > 0) {
                // The key to be deleted is in the right sub-tree
                root.right = this._delete(key, root.right);
            } else {
                // root is the node to be deleted
                if (!root.left && !root.right) {
                    root = null;
                } else if (!root.left && root.right) {
                    root = root.right;
                } else if (root.left && !root.right) {
                    root = root.left;
                } else {
                    // Node has 2 children, get the in-order successor
                    var inOrderSuccessor = minValueNode(root.right);
                    root.key = inOrderSuccessor.key;
                    root.value = inOrderSuccessor.value;
                    root.right = this._delete(inOrderSuccessor.key, root.right);
                }
            }

            if (root === null) {
                return root;
            }

            // Update height and rebalance tree
            root.height = Math.max(root.leftHeight(), root.rightHeight()) + 1;
            var balanceState = getBalanceState(root);

            if (balanceState === BalanceState.UNBALANCED_LEFT) {
                // Left left case
                if (getBalanceState(root.left) === BalanceState.BALANCED ||
                    getBalanceState(root.left) === BalanceState.SLIGHTLY_UNBALANCED_LEFT) {
                    return root.rotateRight();
                }
                // Left right case
                if (getBalanceState(root.left) === BalanceState.SLIGHTLY_UNBALANCED_RIGHT) {
                    root.left = root.left.rotateLeft();
                    return root.rotateRight();
                }
            }

            if (balanceState === BalanceState.UNBALANCED_RIGHT) {
                // Right right case
                if (getBalanceState(root.right) === BalanceState.BALANCED ||
                    getBalanceState(root.right) === BalanceState.SLIGHTLY_UNBALANCED_RIGHT) {
                    return root.rotateLeft();
                }
                // Right left case
                if (getBalanceState(root.right) === BalanceState.SLIGHTLY_UNBALANCED_LEFT) {
                    root.right = root.right.rotateRight();
                    return root.rotateLeft();
                }
            }

            return root;
        };

        /**
         * Gets the value of a node within the tree with a specific key.
         *
         * @param {Object} key The key being searched for.
         * @return {Object} The value of the node or null if it doesn't exist.
         */
        AvlTree.prototype.get = function(key) {
            if (this._root === null) {
                return null;
            }

            return this._get(key, this._root).value;
        };

        /**
         * Gets the value of a node within the tree with a specific key.
         *
         * @private
         * @param {Object} key The key being searched for.
         * @param {Node} root The root of the tree to search in.
         * @return {Object} The node or null if it doesn't exist.
         */
        AvlTree.prototype._get = function(key, root) {
            var result = this._compare(key, root.key);

            if (result === 0) {
                return root;
            }

            if (result < 0) {
                if (!root.left) {
                    return null;
                }
                return this._get(key, root.left);
            }

            if (!root.right) {
                return null;
            }
            return this._get(key, root.right);
        };

        /**
         * Gets whether a node with a specific key is within the tree.
         *
         * @param {Object} key The key being searched for.
         * @return {boolean} Whether a node with the key exists.
         */
        AvlTree.prototype.contains = function(key) {
            if (this._root === null) {
                return false;
            }

            return !!this._get(key, this._root);
        };

        /**
         * @return {Object} The minimum key in the tree.
         */
        AvlTree.prototype.findMinimum = function() {
            return minValueNode(this._root).key;
        };

        /**
         * Gets the minimum value node, rooted in a particular node.
         *
         * @private
         * @param {Node} root The node to search.
         * @return {Node} The node with the minimum key in the tree.
         */
        function minValueNode(root) {
            var current = root;
            while (current.left) {
                current = current.left;
            }
            return current;
        }

        /**
         * @return {Object} The maximum key in the tree.
         */
        AvlTree.prototype.findMaximum = function() {
            return maxValueNode(this._root).key;
        };

        /**
         * Gets the maximum value node, rooted in a particular node.
         *
         * @private
         * @param {Node} root The node to search.
         * @return {Node} The node with the maximum key in the tree.
         */
        function maxValueNode(root) {
            var current = root;
            while (current.right) {
                current = current.right;
            }
            return current;
        }

        /**
         * @return {number} The size of the tree.
         */
        AvlTree.prototype.size = function() {
            return this._size;
        };

        AvlTree.prototype.show = function(node, parentNode) {
            node = node || this._root
            if (!parentNode) {
                parentNode = document.createElement("div");
                document.body.appendChild(parentNode);
                var top = parentNode.appendChild(document.createElement("center"));
                top.style.cssText = "background:" + bg();
                top.innerHTML = node.key;
            }
            var a = parentNode.appendChild(document.createElement("div"))
            a.style.cssText = "overflow:hidden";
            if (node.left) {
                var b = a.appendChild(document.createElement("div"))
                b.style.cssText = "float:left; width:49%;text-align:center;background:" + bg();
                b.innerHTML = node.left.key;
                this.show(node.left, b);
            }
            if (node.right) {
                var c = a.appendChild(document.createElement("div"))
                c.style.cssText = "float:right; width:49%;text-align:center;background:" + bg();
                c.innerHTML = node.right.key;
                this.show(node.right, c);
            }
        }



        /**
         * Represents how balanced a node's left and right children are.
         *
         * @private
         */
        var BalanceState = {
            UNBALANCED_RIGHT: 1,
            SLIGHTLY_UNBALANCED_RIGHT: 2,
            BALANCED: 3,
            SLIGHTLY_UNBALANCED_LEFT: 4,
            UNBALANCED_LEFT: 5
        };

        /**
         * Gets the balance state of a node, indicating whether the left or right
         * sub-trees are unbalanced.
         *
         * @private
         * @param {Node} node The node to get the difference from.
         * @return {BalanceState} The BalanceState of the node.
         */
        function getBalanceState(node) {
            var heightDifference = node.leftHeight() - node.rightHeight();
            switch (heightDifference) {
                case -2:
                    return BalanceState.UNBALANCED_RIGHT;
                case -1:
                    return BalanceState.SLIGHTLY_UNBALANCED_RIGHT;
                case 1:
                    return BalanceState.SLIGHTLY_UNBALANCED_LEFT;
                case 2:
                    return BalanceState.UNBALANCED_LEFT;
                default:
                    return BalanceState.BALANCED;
            }
        }






        function bg() {
            return '#' + (Math.random() * 0xffffff << 0).toString(16);
        }
        var tree = new AvlTree() //一会儿改成AVL
        //  String("14,12,10,8,9").split(",").forEach(function(a) {
        //      tree.insert(~~a)
        //   })
        tree.insert(Math.random())
        tree.insert(Math.random())

        tree.insert(Math.random())

        tree.insert(Math.random())

        tree.insert(Math.random())

        tree.insert(Math.random())

        tree.insert(Math.random())

        tree.insert(Math.random())
        tree.insert(Math.random())
        tree.show()
    </script>


</html>