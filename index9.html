<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">


</head>

<body>


    <div id='root' class="root">

    </div>
    <script>
        class Node {
            constructor(data) {
                this.left = null;
                this.parent = null;
                this.right = null;
                this.height = 0;
                this.data = data;
            }
            /**
             * 右旋
             *
             *       b                           a
             *      / \                         / \
             *     a   e . b.rotateRight() . c   b
             *    / \                             / \
             *   c   d                           d   e
             *
             */
            rotateRight() {
                var other = this.left; //a
                this.left = other.right; //d
                other.right = this;
                this.height = Math.max(this.leftHeight(), this.rightHeight()) + 1;
                other.height = Math.max(other.leftHeight(), this.height) + 1;
                return other;
            }
            /**
             * 左旋
             *
             *     a                              b
             *    / \                            / \
             *   c   b   . a.rotateLeft() .   a   e
             *      / \                        / \
             *     d   e                      c   d
             *
             */
            rotateLeft() {
                var other = this.right;
                this.right = other.left;
                other.left = this;
                this.height = Math.max(this.leftHeight(), this.rightHeight()) + 1;
                other.height = Math.max(other.rightHeight(), this.height) + 1;
                return other;
            }
            leftHeight() {
                if (!this.left) {
                    return -1;
                }
                return this.left.height;
            }
            rightHeight() {
                if (!this.right) {
                    return -1;
                }
                return this.right.height;
            }
        };


        function leftRotate(node) {
            var child = node.right;
            //node下降了，将为补偿，将child.left给node
            node.right = child.left;
            if (child.left) {
                child.left.parent = node;
            }
            var parent = node.parent; //保持之前的父节点
            child.left = node; //左旋

            node.parent = child;
            child.parent = parent;
            if (parent == null) {
                tree.root = child; //如果原来是树，那么child变成根
            } else {
                //如果是原父节点的左节点
                if (node == parent.left) {
                    parent.left = child;
                } else {
                    parent.right = child;
                }
            }
        }

        function rightRotate(node) {
            var child = node.left;
            //node下降了，将为补偿，将child.left给node
            node.left = child.right;
            if (child.right) {
                child.right.parent = node;
            }
            var parent = node.parent; //保持之前的父节点
            child.right = node; //左旋

            node.parent = child;
            child.parent = parent;
            if (parent == null) {
                tree.root = child; //如果原来是树，那么child变成根
            } else {
                //如果是原父节点的左节点
                if (node == parent.left) {
                    parent.left = child;
                } else {
                    parent.right = child;
                }
            }
        }

        class AVL {
            constructor() {
                this.root = null;
                this._size = 0;
            }
            insert(data) {
                if (!this.root) {
                    this.root = new Node(data)
                    this.root.color = "black";
                    this._size = 1
                    return
                }
                var t = this.root,
                    parent, diff;
                do {
                    parent = t;
                    diff = data - t.data
                    //找到适合的位置
                    if (diff < 0) {
                        t = t.left;
                    } else if (diff > 0) {
                        t = t.right;
                    } else {
                        return t;
                    }
                } while (t);
                var node = new Node(data)
                node.parent = parent;
                this._size++;
                if (diff < 0) {
                    parent.left = node;
                } else {
                    parent.right = node;
                }

                this.fixAfterInsertion(node);
            }
            fixAfterInsertion(node) {
                if (node.parent == null) {
                    this.root = node;
                    node.color = BLACK;
                    return
                }
                // https://blog.csdn.net/leetcode8023/article/details/51865628
                //  x.color = "red";
                while (node.parent.color == RED) {
                    if (node.uncle().color === RED) {
                        node.parent.color = node.uncle().color = BLACK;
                        node.grandparent().color = RED;
                        this.fixAfterInsertion(node.grandparent())
                    } else {
                        if (node.parent.right === node && node.grandparent().left === node.parent) {
                            rotateLeft(node);
                            rotateRight(node);
                            node.color = BLACK;
                            node.left.color = p.right.color = RED;
                        } else if (node.parent.left == node && node.grandparent().right == node.parent) {
                            rotateRight(node);
                            rotateLeft(node);
                            node.color = BLACK;
                            node.left.color = p.right.color = RED;
                        } else if(node.parent.left === node && node.grandparent().left == node.parent) {
                            node.parent.color = BLACK;
                            node.grandparent().color = RED;
                            rotateRight(node.parent);
                        } else if(node.parent.right === node && node.grandparent().right == node.parent) {
                            node.parent.color = BLACK;
                            node.grandparent().color = RED;
                            rotateLeft(node.parent);
                        }

                    }
                    var parent = node.parent
                    if (parent.parent) {
                        break
                    }
                    if (parent == parent.parent.left) {
                        //父亲与叔叔都是红色
                        var uncle = parent.parent.right
                        if (uncle.color == "red") { //情况1
                            parent.color = "black";
                            uncle.color = "black";
                            node = parent.parent
                            node.color = "red"
                        } else { // 父亲是红色，叔叔是黑色，自己是父亲的右孩子
                            if (node == parent.right) { //情况4
                                node = node.parent;
                                rotateLeft(node);
                            } //情况5
                            node.parent.color = "black"
                            node.parent.parent.color = "red";
                            rotateRight(node.parent.parent);
                        }
                    } else {
                        uncle = parent.parent.left
                        if (uncle.color == "red") {
                            parent.color = "black";
                            uncle.color = "black";
                            node = parent.parent
                            node.color = "red"
                        } else {
                            if (node == parent.left) { //情况4
                                node = node.parent;
                                rotateRight(node);
                            }
                            node.parent.color = "black"
                            node.parent.parent.color = "red";
                            rotateLeft(node.parent.parent);
                        }
                    }
                }
                root.color = "black";
            }
            _insert(data, root) {
                var node
                if (root === null) { //如果不存在根节点
                    node = new Node(data);
                }
                if (this._size === 0) {
                    node.color = "black";
                    return node;
                } else if (this._size == 1) {

                }
                //console.log(this._size, data, root)
                var diff = data - root.data;
                if (diff < 0) {
                    console.log("=========", root.left)
                    node = root.left = this._insert(data, root);
                } else if (diff > 0) {
                    console.log("111111111", root.right)
                    node = root.right = this._insert(data, root);
                } else {
                    this._size--; //不能重复插入相同值，size减一（因为外面会加－）
                    return root;
                }
                if (root.color == "red") {
                    this._fix(node, root) //修正3，4，5
                }
                return node;
            }

            remove(data) {
                var parent = this.root;
                this.root = this._remove(data, parent);
                if (this.root) {
                    this.root = parent;
                }
                this._size--;
            }
            _remove(data, root) {
                // Perform regular BST deletion
                if (root === null) {
                    this._size++;
                    return root;
                }
                var diff = data - root.data

                if (diff < 0) {
                    // The data to be deleted is in the left sub-tree
                    root.left = this._remove(data, root.left);
                } else if (diff > 0) {
                    // The data to be deleted is in the right sub-tree
                    root.right = this._remove(data, root.right);
                } else {
                    // root is the node to be deleted
                    if (!root.left && !root.right) {
                        root = null;
                    } else if (!root.left && root.right) {
                        root = root.right;
                    } else if (root.left && !root.right) {
                        root = root.left;
                    } else {
                        // Node has 2 children, get the in-order successor
                        var inOrderSuccessor = this.minNode(root.right);
                        root.data = inOrderSuccessor.data;
                        root.right = this._remove(inOrderSuccessor.data, root.right);
                    }
                }

                if (root === null) {
                    return root;
                }

                // Update height and rebalance tree
                root.height = Math.max(root.leftHeight(), root.rightHeight()) + 1;
                var balanceState = getBalance(root);

                if (balanceState === BalanceState.UNBALANCED_LEFT) {
                    // Left left case
                    if (getBalance(root.left) === BalanceState.BALANCED ||
                        getBalance(root.left) === BalanceState.SLIGHTLY_UNBALANCED_LEFT) {
                        return root.rotateRight();
                    }
                    // Left right case
                    if (getBalance(root.left) === BalanceState.SLIGHTLY_UNBALANCED_RIGHT) {
                        root.left = root.left.rotateLeft();
                        return root.rotateRight();
                    }
                }

                if (balanceState === BalanceState.UNBALANCED_RIGHT) {
                    // Right right case
                    if (getBalance(root.right) === BalanceState.BALANCED ||
                        getBalance(root.right) === BalanceState.SLIGHTLY_UNBALANCED_RIGHT) {
                        return root.rotateLeft();
                    }
                    // Right left case
                    if (getBalance(root.right) === BalanceState.SLIGHTLY_UNBALANCED_LEFT) {
                        root.right = root.right.rotateRight();
                        return root.rotateLeft();
                    }
                }

                return root;
            }
            find(data) {
                //....
            }
            minNode(node) {
                var current = node || this.root;
                while (current && current.left) {
                    current = current.left;
                }
                return current;
            }
            maxNode(node) {
                var current = node || this.root;
                while (current && current.right) {
                    current = current.right;
                }
                return current;
            }
            size() {
                return this._size;
            }
            show(node, parentNode) {
                node = node || this.root
                if (!parentNode) {
                    parentNode = document.createElement("div");
                    this.uuid = this.uuid || "uuid" + (new Date - 0)
                    parentNode.id = this.uuid;
                    document.body.appendChild(parentNode);
                    var top = parentNode.appendChild(document.createElement("center"));
                    top.style.cssText = "background:" + bg();
                    top.innerHTML = node.data;
                }
                var a = parentNode.appendChild(document.createElement("div"))
                a.style.cssText = "overflow:hidden";
                if (node.left) {
                    var b = a.appendChild(document.createElement("div"))
                    b.style.cssText = "float:left; width:49%;text-align:center;background:" + bg();
                    b.innerHTML = node.left.data;
                    this.show(node.left, b);
                }
                if (node.right) {
                    var c = a.appendChild(document.createElement("div"))
                    c.style.cssText = "float:right; width:49%;text-align:center;background:" + bg();
                    c.innerHTML = node.right.data;
                    this.show(node.right, c);
                }
            }
            clearNode() {
                var el = document.getElementById(this.uuid);
                if (el) {
                    el.parentNode.removeChild(el)
                }
            }
        }








        function bg() {
            return '#' + (Math.random() * 0xffffff << 0).toString(16);
        }
        var tree = new AVL() //一会儿改成AVL


        Array(16, 10, 17, 8, 13, 11, 12).forEach(function(el) {
            tree.insert(el)

        })
        tree.show()
    </script>


</html>