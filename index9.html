<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">


</head>

<body>


    <div id='root' class="root">

    </div>
    <script>
        var RED = "red";
        var BLACK = "black";
        class Node {
            constructor(data) {
                this.left = null;
                this.parent = null;
                this.right = null;
                this.color = RED;
                this.data = data;
            }

        };

        class RBTree {
            constructor() {
                this.root = null;
                this._size = 0;
            }
            insert(data) {
                if (!this.root) {
                    this.root = new Node(data)
                    this.root.color = BLACK;
                    this._size = 1
                    return
                }
                var t = this.root,
                    parent, diff;
                while (t) {
                    parent = t;
                    diff = data - t.data
                    //找到适合的位置
                    if (diff < 0) {
                        t = t.left;
                    } else if (diff > 0) {
                        t = t.right;
                    } else {
                        return t;
                    }
                }
                var node = new Node(data)
                node.parent = parent;
                this._size++;
                if (diff < 0) {
                    parent.left = node;
                } else {
                    parent.right = node;
                }
                this.insertFixup(node);
            }

            leftRotate(node) {
                if (!node.right) {
                    return;
                }
                var child = node.right;
                node.right = child.left;
                if (child.left) {
                    //过继孩子
                    child.left.parent = node; //父属性修正1
                }
                child.parent = node.parent; //父属性修正2

                //下面都一样
                if (!node.parent) {
                    this.root = child;
                } else if (node == node.parent.left) {
                    node.parent.left = child;
                } else {
                    node.parent.right = child;
                }
                node.parent = child; //父属性修正3
                child.left = node; //旋转
            }
            rightRotate(node) {
                if (!node.left) {
                    return;
                }
                var child = node.left;
                node.left = child.right;
                if (child.right) {
                    //过继孩子
                    child.right.parent = node; //父属性修正1
                }
                child.parent = node.parent; //父属性修正2

                //下面都一样
                if (!node.parent) {
                    this.root = child;
                } else if (node == node.parent.left) {
                    node.parent.left = child;
                } else {
                    node.parent.right = child;
                }
                node.parent = child; //父属性修正3
                child.right = node; //旋转
            }
            insertFixup(node) {

                while (node && node != this.root && node.parent.color == RED) {
                    //
                    // Howerver, we do not need the assertion of non-nil grandparent
                    // because
                    //
                    //  2) The root is black
                    //
                    // Since the color of the parent is RED, so the parent is not root
                    // and the grandparent must be exist.
                    //
                    if (node.parent == node.parent.parent.left) {
                        // Take y as the uncle, although it can be NIL, in that case
                        // its color is BLACK
                        var uncle = node.parent.parent.right
                        //uncle不存在当作黑
                        if (uncle && uncle.color == RED) {

                            node.parent.color = BLACK
                            uncle.color = BLACK
                            node.parent.parent.color = RED
                            node = node.parent.parent
                        } else {
                            if (node == node.parent.right) {

                                node = node.parent
                                this.leftRotate(node)
                            }

                            node.parent.color = BLACK
                            node.parent.parent.color = RED
                            this.rightRotate(node.parent.parent)
                        }
                    } else { // same as then clause with "right" and "left" exchanged
                        uncle = node.parent.parent.left
                        if (uncle && uncle.color == RED) {
                            node.parent.color = BLACK
                            uncle.color = BLACK

                            node.parent.parent.color = RED
                            node = node.parent.parent
                        } else {
                            if (node == node.parent.left) {
                                node = node.parent
                                this.rightRotate(node)
                            }
                            node.parent.color = BLACK
                            node.parent.parent.color = RED
                            this.leftRotate(node.parent.parent)
                        }
                    }
                }
                this.root.color = BLACK
            }


            remove(data) {
                var parent = this.root;
                this.root = this._remove(data, parent);
                if (this.root) {
                    this.root = parent;
                }
                this._size--;
            }
            size() {
                return this._size;
            }
            show(node, parentNode) {
                node = node || this.root
                if (!parentNode) {
                    parentNode = document.createElement("div");
                    this.uuid = this.uuid || "uuid" + (new Date - 0)
                    parentNode.id = this.uuid;
                    document.body.appendChild(parentNode);
                    var top = parentNode.appendChild(document.createElement("center"));
                    top.style.cssText = "background:" + bg(node)
                    top.innerHTML = node.data;
                }

                var a = parentNode.appendChild(document.createElement("div"))
                a.style.cssText = "overflow:hidden";
                if (node.left) {
                    var b = a.appendChild(document.createElement("div"))
                    b.style.cssText = style("left") + bg(node.left)
                    b.innerHTML = node.left.data;
                    this.show(node.left, b);
                }
                if (node.right) {
                    var c = a.appendChild(document.createElement("div"))

                    c.style.cssText = style("right") + bg(node.right)
                    c.innerHTML = node.right.data;

                    this.show(node.right, c);
                }
            }

        }


        function style(dir) {
            return `box-sizing: border-box;float:${dir}; width:49%;text-align:center;background:`
        }

        function bg(node) {
            return node.color === "red" ? "pink;border:1px solid red;" : "gray;border:1px solid black"
        }
        var tree = new RBTree() //一会儿改成AVL


        var id = setInterval(function () {
            var el = ~~(Math.random() + "").slice(-3)

            if (tree._size > 35) {
                clearInterval(id)
                tree.show()
                return
            }
            // tree.clearNode()
            tree.insert(el)

        }, 30)
        // https://www.cnblogs.com/xrq730/p/6867924.html
        // https://blog.csdn.net/u011240877/article/details/53329023
        // https://www.cnblogs.com/skywang12345/p/3624343.html
    </script>


</html>