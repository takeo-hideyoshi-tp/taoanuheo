<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script type='text/javascript' src="./dist/React.js"></script>
     <!-- <script type='text/javascript' src="./react.js"></script>
      <script type='text/javascript' src="./react-dom.js"></script>-->
    <script type='text/javascript' src="./lib/ReactTestUtils.js"></script>
    <script type='text/javascript' src="./lib/babel.js"></script>

</head>

<body>

    <pre>React 15 </pre>


    <div id='root' class="root">

    </div>
    <script type='text/babel'>
        
        var container = document.getElementById('root');
          var div = container;
          if (!window.ReactDOM) {
              window.ReactDOM = React;
		  }
	    var log = {
			push(a){
				console.log(a)
			}
		}
        var log = []
		  var PropTypes = React.PropTypes;
		
		
          var expect = function(a) {
              return {
                  toBe: function(b) {
                      console.log(a, 'vs', b, a === b);
                  },
                  toEqual(b) {
                      console.log(a, 'vs', b, a + '' === b + '');
				  },
				  toWarnDev(b){
					try{
                          a()
                      }catch(e){
                          console.log(e,"warn")
                      }
				  },
                  toThrow(){
                      try{
                          a()
                      }catch(e){
                          console.log(e,"catch")
                      }
                  }
              };
		 };
//================================
function dispatchEventOnNode(node, type) {
    node.dispatchEvent(new Event(type, {bubbles: true, cancelable: true}));
  }

   
   var setUntrackedValue = Object.getOwnPropertyDescriptor(
      HTMLInputElement.prototype,
      'value',
    ).set;
	function it(a, b){
		console.log(a)
		b()
	}

  it('should properly control a value even if no event listener exists', () => {
    const container = document.createElement('div');
    let stub;

    expect(() => {
      stub = ReactDOM.render(<input type="text" value="lion" />, container);
    }).toWarnDev(
      'Failed prop type: You provided a `value` prop to a form field without an `onChange` handler.',
    );

    document.body.appendChild(container);

    const node = ReactDOM.findDOMNode(stub);

    setUntrackedValue.call(node, 'giraffe');

    // This must use the native event dispatching. If we simulate, we will
    // bypass the lazy event attachment system so we won't actually test this.
    dispatchEventOnNode(node, 'change');

    expect(node.value).toBe('lion');

    document.body.removeChild(container);
  });



  it('treats initial function value as an empty string', function () {
    const container = document.createElement('div');

    ReactDOM.render(
      <input value={() => { }} onChange={() => { }} />,
      container,
    )

    const node = container.firstChild;

    expect(node.value).toBe('');
    expect(node.getAttribute('value')).toBe('');
  });

  it('treats updated function value as an empty string', function () {
    const container = document.createElement('div');
    ReactDOM.render(<input value="foo" onChange={() => { }} />, container);
    expect(() =>
      ReactDOM.render(
        <input value={() => { }} onChange={() => { }} />,
        container,
      ),
    ).toWarnDev('Invalid value for prop `value`');
    const node = container.firstChild;

    expect(node.value).toBe('');
    expect(node.getAttribute('value')).toBe('');
  });

  it('treats initial function defaultValue as an empty string', function () {
    const container = document.createElement('div');
    ReactDOM.render(<input defaultValue={() => { }} />, container);
    const node = container.firstChild;

    expect(node.value).toBe('');
    expect(node.getAttribute('value')).toBe('');
    // TODO: we should warn here.
  });

  it('treats updated function defaultValue as an empty string', function () {
    const container = document.createElement('div');
    ReactDOM.render(<input defaultValue="foo" />, container);
    ReactDOM.render(<input defaultValue={() => { }} />, container);
    const node = container.firstChild;

    expect(node.value).toBe('foo');
    expect(node.getAttribute('value')).toBe('');
    // TODO: we should warn here.
  });

  // In absence of a value, radio and checkboxes report a value of "on".
  // Between 16 and 16.2, we assigned a node's value to it's current
  // value in order to "dettach" it from defaultValue. This had the unfortunate
  // side-effect of assigning value="on" to radio and checkboxes
  it('does not add "on" in absence of value on a checkbox', function () {
    const container = document.createElement('div');
    ReactDOM.render(
      <input type="checkbox" defaultChecked={true} />,
      container,
    );
    const node = container.firstChild;

    expect(node.value).toBe('on');
    expect(node.hasAttribute('value')).toBe(false);
  });

  it('does not add "on" in absence of value on a radio', function () {
    const container = document.createElement('div');
    ReactDOM.render(<input type="radio" defaultChecked={true} />, container);
    const node = container.firstChild;

    expect(node.value).toBe('on');
    expect(node.hasAttribute('value')).toBe(false);
    ReactDOM.unmountComponentAtNode(container)
  });


  it('只执行一次', function () {
    console.log('--------BEGIN----------')
    const container = document.createElement('div');
    document.body.appendChild(container)
    var logIndex = 0;
    function refFn(e) {
      logIndex++;
    }

    var dom = ReactDOM.render(<input className={new Date+""} type="checkbox" onChange={refFn} />, container);
	console.log("click......")
	dom.click()
    expect(logIndex).toBe(1)
    console.log("-------END-------------",dom)
   // ReactDOM.unmountComponentAtNode(container)
  // document.body.removeChild(container)
  
  });

    </script>


</html>
