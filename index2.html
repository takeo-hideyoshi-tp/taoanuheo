<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">


</head>

<body>

  <div id='root' class="root">

  </div>
  <script>
  class BinaryIndexedTree {
    /**
     * 为了统一下标，所以tree[0]不被使用，数组有效范围1~length。
     * */
            constructor(array) {
                var n = array.length;
                this.length = n;
                this._sum = new Array(n + 1).fill(0)
                console.log(this._sum.concat(), '---')
                for (var i = 0; i < n; i++) {
                 //   console.log(i+1, array[i])
                    this.add(i+1, array[i], i+1)
                    console.log('=======')
                }
                console.log(this._sum.concat(), '---')
            }
            /**
             * 计算1~index范围内和
             * index一直减去lowBit(index)，直到index为0
             * */
            sum(index) {
                if (index < 1 && index > this.length) {
                    throw new RangeError("Out of Range!");
                }
                var sum = 0;
                while (index > 0) {
                    sum += this._sum[index];
                    index -= lowBit(index);
                }
                return sum;
            }
              /**
             * index一直减去lowBit(index)，直到index为length。这些位置的值都加上value
             * */
             get(index) {
                if (index < 1 && index > this.length) {
                    throw new IllegalArgumentException("Out of Range!");
                }
                var sum = this._sum[index];
                var z = index - lowBit(index);
                index--;
                while (index != z) {
                    sum -= this._sum[index];
                    index -= lowBit(index);
                }
                return sum;
            }
            /**
             * 计算start~end范围内和
             * */
            queryRangeSum(start, end) {
                return this.querySum(end) - this.querySum(start - 1);
            }
            /**
             * index一直加上lowBit(index)，直到index为length。这些位置的值都加上value
             * */
            add(index, value, breakIndex) {
                if (index < 1 && index > this.length) {
                    throw new IllegalArgumentException("Out of Range!");
                }
             
                while (index <= this.length ) {
                    this._sum[index] += value;
                    index += lowBit(index);//找到其父节点的索引
                }
            }
          

        }
        // 保留k的二进制最低位1的值。例如，1110保留最低位1即0010.
        function lowBit(k) {
            return k & -k;
        }

        var t = new BinaryIndexedTree([10, 18, 12, 5, 7, 11, 4, 15])
        /**
         *  10
         *  28 = 10+18
         *  12
         *  45 = 28+12+5
         *  7
         *  18 = 7+11
         *  4
         *  82 = 45+18+4+15
         */
     console.log(t)
       //

       function prefixSum(x, c){
            var nodes = [], res = 0
            if( x === lowbit(x)){
                x = x - 1;
            }
            while(x){
                res + c[x]
                var child = lowbit(x);
                if(child === x){
                    break
                }
                x = x - child
            }
            return res
       }
       
    
function lowbit(x){
    return x & (-x)
}


    </script>
    </body>
</html>